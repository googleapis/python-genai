# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Code generated by the Google Gen AI SDK generator DO NOT EDIT.

from functools import cached_property
import io
import json
import logging
import os
from typing import Any, Optional, Union
from urllib.parse import urlencode

from .. import _api_module
from .. import _common
from .._common import get_value_by_path as getv
from .._common import set_value_by_path as setv
from ..pagers import AsyncPager, Pager
from . import _extra_utils
from . import types
from .documents import AsyncDocuments, Documents


logger = logging.getLogger('google_genai.ragstores')


def _CreateRagStoreConfig_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}

  if getv(from_object, ['display_name']) is not None:
    setv(parent_object, ['displayName'], getv(from_object, ['display_name']))

  return to_object


def _CreateRagStoreParameters_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['config']) is not None:
    setv(
        to_object,
        ['config'],
        _CreateRagStoreConfig_to_mldev(
            getv(from_object, ['config']), to_object
        ),
    )

  return to_object


def _DeleteRagStoreConfig_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}

  if getv(from_object, ['force']) is not None:
    setv(parent_object, ['_query', 'force'], getv(from_object, ['force']))

  return to_object


def _DeleteRagStoreParameters_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['name']) is not None:
    setv(to_object, ['_url', 'name'], getv(from_object, ['name']))

  if getv(from_object, ['config']) is not None:
    setv(
        to_object,
        ['config'],
        _DeleteRagStoreConfig_to_mldev(
            getv(from_object, ['config']), to_object
        ),
    )

  return to_object


def _GetRagStoreParameters_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['name']) is not None:
    setv(to_object, ['_url', 'name'], getv(from_object, ['name']))

  if getv(from_object, ['config']) is not None:
    setv(to_object, ['config'], getv(from_object, ['config']))

  return to_object


def _ListRagStoresConfig_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}

  if getv(from_object, ['page_size']) is not None:
    setv(
        parent_object, ['_query', 'pageSize'], getv(from_object, ['page_size'])
    )

  if getv(from_object, ['page_token']) is not None:
    setv(
        parent_object,
        ['_query', 'pageToken'],
        getv(from_object, ['page_token']),
    )

  return to_object


def _ListRagStoresParameters_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['config']) is not None:
    setv(
        to_object,
        ['config'],
        _ListRagStoresConfig_to_mldev(getv(from_object, ['config']), to_object),
    )

  return to_object


def _ListRagStoresResponse_from_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['sdkHttpResponse']) is not None:
    setv(
        to_object, ['sdk_http_response'], getv(from_object, ['sdkHttpResponse'])
    )

  if getv(from_object, ['nextPageToken']) is not None:
    setv(to_object, ['next_page_token'], getv(from_object, ['nextPageToken']))

  if getv(from_object, ['ragStores']) is not None:
    setv(
        to_object,
        ['rag_stores'],
        [item for item in getv(from_object, ['ragStores'])],
    )

  return to_object


def _UploadToRagStoreConfig_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}

  if getv(from_object, ['mime_type']) is not None:
    setv(to_object, ['mimeType'], getv(from_object, ['mime_type']))

  if getv(from_object, ['custom_metadata']) is not None:
    setv(
        parent_object,
        ['customMetadata'],
        [item for item in getv(from_object, ['custom_metadata'])],
    )

  if getv(from_object, ['chunking_config']) is not None:
    setv(
        parent_object,
        ['chunkingConfig'],
        getv(from_object, ['chunking_config']),
    )

  return to_object


def _UploadToRagStoreOperation_from_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['name']) is not None:
    setv(to_object, ['name'], getv(from_object, ['name']))

  if getv(from_object, ['metadata']) is not None:
    setv(to_object, ['metadata'], getv(from_object, ['metadata']))

  if getv(from_object, ['done']) is not None:
    setv(to_object, ['done'], getv(from_object, ['done']))

  if getv(from_object, ['error']) is not None:
    setv(to_object, ['error'], getv(from_object, ['error']))

  if getv(from_object, ['response']) is not None:
    setv(
        to_object,
        ['response'],
        _UploadToRagStoreResponse_from_mldev(
            getv(from_object, ['response']), to_object
        ),
    )

  return to_object


def _UploadToRagStoreParameters_to_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['rag_store_name']) is not None:
    setv(
        to_object,
        ['_url', 'rag_store_name'],
        getv(from_object, ['rag_store_name']),
    )

  if getv(from_object, ['config']) is not None:
    setv(
        to_object,
        ['config'],
        _UploadToRagStoreConfig_to_mldev(
            getv(from_object, ['config']), to_object
        ),
    )

  return to_object


def _UploadToRagStoreResponse_from_mldev(
    from_object: Union[dict[str, Any], object],
    parent_object: Optional[dict[str, Any]] = None,
) -> dict[str, Any]:
  to_object: dict[str, Any] = {}
  if getv(from_object, ['sdkHttpResponse']) is not None:
    setv(
        to_object, ['sdk_http_response'], getv(from_object, ['sdkHttpResponse'])
    )

  if getv(from_object, ['parent']) is not None:
    setv(to_object, ['parent'], getv(from_object, ['parent']))

  if getv(from_object, ['documentName']) is not None:
    setv(to_object, ['document_name'], getv(from_object, ['documentName']))

  return to_object


class RagStores(_api_module.BaseModule):

  @cached_property
  def documents(self) -> Documents:
    return Documents(self._api_client)

  def create(
      self, *, config: Optional[types.CreateRagStoreConfigOrDict] = None
  ) -> types.RagStore:
    """Creates a Rag Store.

    Args:
      config (CreateRagStoreConfig | None): Optional parameters for the request.

    Returns:
      RagStore
    """

    parameter_model = types._CreateRagStoreParameters(
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _CreateRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'ragStores'.format_map(request_url_dict)
      else:
        path = 'ragStores'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request(
        'post', path, request_dict, http_options
    )

    response_dict = {} if not response.body else json.loads(response.body)

    return_value = types.RagStore._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  def get(
      self, *, name: str, config: Optional[types.GetRagStoreConfigOrDict] = None
  ) -> types.RagStore:
    """Gets metadata about a RagStore.

    Args:
      name (str): The resource name of the RagStore. Example:
        `ragStores/my-rag-store-123`
      config (GetRagStoreConfig | None): Optional parameters for the request.

    Returns:
      A RagStore object containing the metadata.
    """

    parameter_model = types._GetRagStoreParameters(
        name=name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _GetRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = '{name}'.format_map(request_url_dict)
      else:
        path = '{name}'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request('get', path, request_dict, http_options)

    response_dict = {} if not response.body else json.loads(response.body)

    return_value = types.RagStore._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  def delete(
      self,
      *,
      name: str,
      config: Optional[types.DeleteRagStoreConfigOrDict] = None,
  ) -> None:
    """Deletes a RagStore.

    Args:
      name (str): The resource name of the RagStore. Example:
        `ragStores/my-rag-store-123`
      config (DeleteRagStoreConfig | None): Optional parameters for the request.

    Returns:
      None
    """

    parameter_model = types._DeleteRagStoreParameters(
        name=name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _DeleteRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = '{name}'.format_map(request_url_dict)
      else:
        path = '{name}'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request(
        'delete', path, request_dict, http_options
    )

  def _list(
      self, *, config: Optional[types.ListRagStoresConfigOrDict] = None
  ) -> types.ListRagStoresResponse:
    """Lists all RagStores owned by the user.

    Args:
      config (ListRagStoresConfig | None): Optional parameters for the request,
        such as page_size.

    Returns:
      ListRagStoresResponse: A paginated list of RagStores.
    """

    parameter_model = types._ListRagStoresParameters(
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _ListRagStoresParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'ragStores'.format_map(request_url_dict)
      else:
        path = 'ragStores'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request('get', path, request_dict, http_options)

    response_dict = {} if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = _ListRagStoresResponse_from_mldev(response_dict)

    return_value = types.ListRagStoresResponse._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  def _upload_to_rag_store(
      self,
      *,
      rag_store_name: str,
      config: Optional[types.UploadToRagStoreConfigOrDict] = None,
  ) -> types.UploadToRagStoreOperation:
    parameter_model = types._UploadToRagStoreParameters(
        rag_store_name=rag_store_name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _UploadToRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'upload/v1beta/{rag_store_name}:uploadToRagStore'.format_map(
            request_url_dict
        )
      else:
        path = 'upload/v1beta/{rag_store_name}:uploadToRagStore'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = self._api_client.request(
        'post', path, request_dict, http_options
    )

    if config is not None and getattr(
        config, 'should_return_http_response', None
    ):
      return_value = types.UploadToRagStoreOperation(sdk_http_response=response)
      self._api_client._verify_response(return_value)
      return return_value

    response_dict = {} if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = _UploadToRagStoreOperation_from_mldev(response_dict)

    return_value = types.UploadToRagStoreOperation._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  def upload_to_rag_store(
      self,
      *,
      rag_store_name: str,
      file: Union[str, os.PathLike[str], io.IOBase],
      config: Optional[types.UploadToRagStoreConfigOrDict] = None,
  ) -> types.UploadToRagStoreOperation:
    """Calls the API to upload a file to the given rag store.

    Args:
      rag_store_name: The resource name of the RagStore. Example:
        `ragStores/rag-store-123`
      file: A path to the file or an `IOBase` object to be uploaded. If it's an
        IOBase object, it must be opened in blocking (the default) mode and
        binary mode. In other words, do not use non-blocking mode or text mode.
        The given stream must be seekable, that is, it must be able to call
        `seek()` on 'path'.
      config: Optional parameters to set `diplay_name`, `mime_type`, and others.
    """
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    if config is None:
      user_config_dict = {}
    elif isinstance(config, dict):
      user_config_dict = config.copy()
    else:
      user_config_dict = config.model_dump(exclude_unset=True)

    http_options, size_bytes, _ = _extra_utils.prepare_resumable_upload(
        file,
        user_http_options=user_config_dict.get('http_options'),
        user_mime_type=user_config_dict.get('mime_type'),
    )
    final_config_dict = {
        **user_config_dict,
        'http_options': http_options,
        'should_return_http_response': True,
    }
    response = self._upload_to_rag_store(
        rag_store_name=rag_store_name,
        config=types.UploadToRagStoreConfig(**final_config_dict),
    )
    if (
        response.sdk_http_response is None
        or response.sdk_http_response.headers is None
        or (
            'x-goog-upload-url' not in response.sdk_http_response.headers
            and 'X-Goog-Upload-URL' not in response.sdk_http_response.headers
        )
    ):
      raise KeyError(
          'Failed to upload file to rag store. Upload URL did not returned from'
          ' the upload request.'
      )
    elif 'x-goog-upload-url' in response.sdk_http_response.headers:
      upload_url = response.sdk_http_response.headers['x-goog-upload-url']
    else:
      upload_url = response.sdk_http_response.headers['X-Goog-Upload-URL']
    if isinstance(file, io.IOBase):
      upload_response = self._api_client.upload_file(
          file, upload_url, size_bytes, http_options=http_options
      )
    else:
      fs_path = os.fspath(file)
      upload_response = self._api_client.upload_file(
          fs_path, upload_url, size_bytes, http_options=http_options
      )
    response_dict = _UploadToRagStoreOperation_from_mldev(upload_response.json)
    return types.UploadToRagStoreOperation._from_response(
        response=response_dict, kwargs={}
    )

  def list(
      self, *, config: Optional[types.ListRagStoresConfigOrDict] = None
  ) -> Pager[types.RagStore]:
    """Lists RagStores.

    Args:
      config (ListRagStoresConfig): Optional configuration for the list request.

    Returns:
      A Pager object that contains one page of rag stores. When iterating over
      the pager, it automatically fetches the next page if there are more.

    Usage:

    .. code-block:: python
      for rag_store in client.rag_stores.list():
        print(f"rag store: {rag_store.name} - {rag_store.display_name}")
    """
    if config is None:
      config = types.ListRagStoresConfig()
    return Pager(
        'rag_stores',
        self._list,
        self._list(config=config),
        config,
    )


class AsyncRagStores(_api_module.BaseModule):

  @cached_property
  def documents(self) -> AsyncDocuments:
    return AsyncDocuments(self._api_client)

  async def create(
      self, *, config: Optional[types.CreateRagStoreConfigOrDict] = None
  ) -> types.RagStore:
    """Creates a Rag Store.

    Args:
      config (CreateRagStoreConfig | None): Optional parameters for the request.

    Returns:
      RagStore
    """

    parameter_model = types._CreateRagStoreParameters(
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _CreateRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'ragStores'.format_map(request_url_dict)
      else:
        path = 'ragStores'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'post', path, request_dict, http_options
    )

    response_dict = {} if not response.body else json.loads(response.body)

    return_value = types.RagStore._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  async def get(
      self, *, name: str, config: Optional[types.GetRagStoreConfigOrDict] = None
  ) -> types.RagStore:
    """Gets metadata about a RagStore.

    Args:
      name (str): The resource name of the RagStore. Example:
        `ragStores/my-rag-store-123`
      config (GetRagStoreConfig | None): Optional parameters for the request.

    Returns:
      A RagStore object containing the metadata.
    """

    parameter_model = types._GetRagStoreParameters(
        name=name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _GetRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = '{name}'.format_map(request_url_dict)
      else:
        path = '{name}'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'get', path, request_dict, http_options
    )

    response_dict = {} if not response.body else json.loads(response.body)

    return_value = types.RagStore._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  async def delete(
      self,
      *,
      name: str,
      config: Optional[types.DeleteRagStoreConfigOrDict] = None,
  ) -> None:
    """Deletes a RagStore.

    Args:
      name (str): The resource name of the RagStore. Example:
        `ragStores/my-rag-store-123`
      config (DeleteRagStoreConfig | None): Optional parameters for the request.

    Returns:
      None
    """

    parameter_model = types._DeleteRagStoreParameters(
        name=name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _DeleteRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = '{name}'.format_map(request_url_dict)
      else:
        path = '{name}'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'delete', path, request_dict, http_options
    )

  async def _list(
      self, *, config: Optional[types.ListRagStoresConfigOrDict] = None
  ) -> types.ListRagStoresResponse:
    """Lists all RagStores owned by the user.

    Args:
      config (ListRagStoresConfig | None): Optional parameters for the request,
        such as page_size.

    Returns:
      ListRagStoresResponse: A paginated list of RagStores.
    """

    parameter_model = types._ListRagStoresParameters(
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _ListRagStoresParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'ragStores'.format_map(request_url_dict)
      else:
        path = 'ragStores'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'get', path, request_dict, http_options
    )

    response_dict = {} if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = _ListRagStoresResponse_from_mldev(response_dict)

    return_value = types.ListRagStoresResponse._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  async def _upload_to_rag_store(
      self,
      *,
      rag_store_name: str,
      config: Optional[types.UploadToRagStoreConfigOrDict] = None,
  ) -> types.UploadToRagStoreOperation:
    parameter_model = types._UploadToRagStoreParameters(
        rag_store_name=rag_store_name,
        config=config,
    )

    request_url_dict: Optional[dict[str, str]]
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    else:
      request_dict = _UploadToRagStoreParameters_to_mldev(parameter_model)
      request_url_dict = request_dict.get('_url')
      if request_url_dict:
        path = 'upload/v1beta/{rag_store_name}:uploadToRagStore'.format_map(
            request_url_dict
        )
      else:
        path = 'upload/v1beta/{rag_store_name}:uploadToRagStore'

    query_params = request_dict.get('_query')
    if query_params:
      path = f'{path}?{urlencode(query_params)}'
    # TODO: remove the hack that pops config.
    request_dict.pop('config', None)

    http_options: Optional[types.HttpOptions] = None
    if (
        parameter_model.config is not None
        and parameter_model.config.http_options is not None
    ):
      http_options = parameter_model.config.http_options

    request_dict = _common.convert_to_dict(request_dict)
    request_dict = _common.encode_unserializable_types(request_dict)

    response = await self._api_client.async_request(
        'post', path, request_dict, http_options
    )

    if config is not None and getattr(
        config, 'should_return_http_response', None
    ):
      return_value = types.UploadToRagStoreOperation(sdk_http_response=response)
      self._api_client._verify_response(return_value)
      return return_value

    response_dict = {} if not response.body else json.loads(response.body)

    if not self._api_client.vertexai:
      response_dict = _UploadToRagStoreOperation_from_mldev(response_dict)

    return_value = types.UploadToRagStoreOperation._from_response(
        response=response_dict, kwargs=parameter_model.model_dump()
    )

    self._api_client._verify_response(return_value)
    return return_value

  async def upload_to_rag_store(
      self,
      *,
      rag_store_name: str,
      file: Union[str, os.PathLike[str], io.IOBase],
      config: Optional[types.UploadToRagStoreConfigOrDict] = None,
  ) -> types.UploadToRagStoreOperation:
    """Calls the API to upload a file to the given rag store.

    Args:
      rag_store_name: The resource name of the RagStore. Example:
        `ragStores/rag-store-123`
      file: A path to the file or an `IOBase` object to be uploaded. If it's an
        IOBase object, it must be opened in blocking (the default) mode and
        binary mode. In other words, do not use non-blocking mode or text mode.
        The given stream must be seekable, that is, it must be able to call
        `seek()` on 'path'.
      config: Optional parameters to set `diplay_name`, `mime_type` and others.
    """
    if self._api_client.vertexai:
      raise ValueError(
          'This method is only supported in the Gemini Developer client.'
      )
    if config is None:
      user_config_dict = {}
    elif isinstance(config, dict):
      user_config_dict = config.copy()
    else:
      user_config_dict = config.model_dump(exclude_unset=True)

    http_options, size_bytes, _ = _extra_utils.prepare_resumable_upload(
        file,
        user_http_options=user_config_dict.get('http_options'),
        user_mime_type=user_config_dict.get('mime_type'),
    )
    final_config_dict = {
        **user_config_dict,
        'http_options': http_options,
        'should_return_http_response': True,
    }
    response = await self._upload_to_rag_store(
        rag_store_name=rag_store_name,
        config=types.UploadToRagStoreConfig(**final_config_dict),
    )
    if (
        response.sdk_http_response is None
        or response.sdk_http_response.headers is None
        or (
            'x-goog-upload-url' not in response.sdk_http_response.headers
            and 'X-Goog-Upload-URL' not in response.sdk_http_response.headers
        )
    ):
      raise KeyError(
          'Failed to upload file to rag store. Upload URL did not returned from'
          ' the upload request.'
      )
    elif 'x-goog-upload-url' in response.sdk_http_response.headers:
      upload_url = response.sdk_http_response.headers['x-goog-upload-url']
    else:
      upload_url = response.sdk_http_response.headers['X-Goog-Upload-URL']
    if isinstance(file, io.IOBase):
      upload_response = await self._api_client.async_upload_file(
          file, upload_url, size_bytes, http_options=http_options
      )
    else:
      fs_path = os.fspath(file)
      upload_response = await self._api_client.async_upload_file(
          fs_path, upload_url, size_bytes, http_options=http_options
      )
    response_dict = _UploadToRagStoreOperation_from_mldev(upload_response.json)
    return types.UploadToRagStoreOperation._from_response(
        response=response_dict, kwargs={}
    )

  async def list(
      self, *, config: Optional[types.ListRagStoresConfigOrDict] = None
  ) -> AsyncPager[types.RagStore]:
    """Lists RagStores asynchronously.

    Args:
      config (ListRagStoresConfig): Optional configuration for the list request.

    Returns:
      A Pager object that contains one page of RagStores. When iterating over
      the pager, it automatically fetches the next page if there are more.

    Usage:

    .. code-block:: python
      async for rag_store in await client.rag_stores.list():
        print(f"rag store: {rag_store.name} - {rag_store.display_name}")
    """
    if config is None:
      config = types.ListRagStoresConfig()
    return AsyncPager(
        'rag_stores',
        self._list,
        await self._list(config=config),
        config,
    )
